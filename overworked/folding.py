# -*- coding: utf-8 -*-

"""
===========
Folding Art
===========

Calculate how to fold pages to print an image into the depth of a book.

It is chosen to match the aspect ratio of the pattern, which is considered fixed.
To adjust the aspect ratio of the folded pattern, you can play with :
    - the book size (sheet size, number of pages)
    - the margins around the folded pattern (optimal values are calculated)
    - the opening of the book (3 cases : 90, 180 and 360)
"""

from __future__ import division, print_function, absolute_import

from PIL import Image

from typical import checks, numeric

###############################################################################
# OUTPUT CONSTANTS
###############################################################################

IMAGE_SPECIFICATIONS_STR = """image ({width} x {height}) ratio {ratio}"""

PATTERN_SPECIFICATIONS_STR = """pattern ({width} x {height}) ratio {ratio}"""

BOOK_PAGE = """
"""

SHEET_SIZE_LINE ="""
"""

HORIZONTAL_MARGIN_LINE = """
"""

VERTICAL_MARGIN_LINE = """
"""

FOLDING_TABLE_DISCLAIMER = """{pattern_name:=<080}
The folding marks are measured from the bottom of the page.
The blank pages are meant to be folded all the way, from top to bottom.
The measures are given in cm.
===============================================================================
"""

FOLDING_TABLE_HEADER = """
===============================================================================
{page: <04}\t{lower_mark: <05}\t{upper_mark: <05}
===============================================================================\n"""

FOLDING_TABLE_FOOTER = """
===============================================================================
Generated by the OverWorked Moodule.
Licensed under GPL v3.
Enjoy your time folding !"""

FOLDING_TABLE_BLANK_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\tThis page is WHITE = folded all the way!\n"""

FOLDING_TABLE_FOLDED_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\n"""

FOLDING_TABLE_BLACK_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\tThis page is BLACK = not folded !\n"""

NOT_ENOUGH_PAGES_WARNING = """! The book has only {sheet_count} sheets of paper while the pattern requires {band_count} !"""

###############################################################################
# COORDINATES
###############################################################################

@checks
def aspect_ratio(
        width: int,
        height: int) -> numeric:
    """
    Calculates the aspect ratio of an image or a pattern.

    Parameters
    ----------
    width:
        The width of the image in pixels.
        Or the width of the pattern as a slice count.
    height:
        The height of the image / pattern in pixels.

    Returns
    -------
        The aspect ratio of the image or pattern.
    """
    return float(width / height)

@checks
def coordinate_ratio(
        coordinate: int,
        dimension: int,
        reverse: bool=True) -> numeric:
    """
    Calculates the relative position of a pixel.

    Parameters
    ----------
    coordinate:
        The position as a pixel count.
    dimension:
        The size of the object as a pixel count.
    reverse:
        Whether to count from the lower or upper bound.

    Returns
    -------
        The position as a ratio.
    """
    __r =  min(
        1.0,
        max(
            0.0,
            float(coordinate) /float(dimension)))
    if reverse:
        return 1.0 - __r
    else:
        return __r

def _pixel_to_sheet_coordinate(self, pixel_y):
    pixel_ratio = self._pattern.vertical_coordinate_ratio(pixel_y, from_top=False, raw=False)
    coordinate = self._vertical_margin + (pixel_ratio * self.sheet_height()[1])
    return coordinate

###############################################################################
# PATTERN
###############################################################################

@checks
def is_white_band(
        band_start: int,
        band_end: int) -> bool:
    """
    Says whether a pattern band is blank.
    """
    return (band_start == band_end)

@checks
def is_black_band(
        band_start: int,
        band_end: int,
        band_length) -> bool:
    """
    Says whether a pattern band is black.
    """
    return ((band_start <= 0)
        and (band_end >= (band_length - 1)))

#####################################################################
# VIEWING & EXPORTING
#####################################################################

Image.show()
Image.save(
    fp='path',
    format='png')

def _generate_pattern_image(sheet_width=3):
    pattern_image_width = sheet_width * self.width(raw=False)
    self._pattern_image = Image.new('1', (pattern_image_width, self.height(raw=True)), True)
    for i in xrange(self.width(raw=False)):
        self._fill_image_band(i, sheet_width)

def _band_to_folding_marks_line_str(self, index, band):
    folding_marks_line = ''
    current_page = self._first_page + 2 * self._horizontal_margin + 2 * index
    lower_mark = 100.0 * self._pixel_to_sheet_coordinate(band[1])
    upper_mark = 100.0 * self._pixel_to_sheet_coordinate(band[0])
    if self._pattern.is_white_band(band):
        lower_mark = 0.0
        upper_mark = 100.0 * self._sheet_height
        folding_marks_line = FOLDING_TABLE_BLANK_LINE.format(
                page=current_page,
                lower=lower_mark,
                upper=upper_mark)
    elif self._pattern.is_black_band(band):
        if not self._vertical_margin:
            folding_marks_line = FOLDING_TABLE_BLACK_LINE.format(
                    page = current_page,
                    lower = '-',
                    upper = '-')
    else:
        folding_marks_line = FOLDING_TABLE_FOLDED_LINE.format(
                page=current_page,
                lower=lower_mark,
                upper=upper_mark)
    return folding_marks_line

def save_folding_table(self, pattern_name='', pattern_path=''):
    saving_path = _tools.full_path_to_file(
            name=self.name() if not pattern_name else pattern_name,
            path='./' if not pattern_path else pattern_path,
            extension='txt')

    with open(saving_path, 'w') as pattern_file:
   
        folding_table = FOLDING_TABLE_DISCLAIMER.format(
            pattern_name='= ' + self._pattern.name() + ' ')
        
        folding_table += FOLDING_TABLE_HEADER.format(
            page='Page',
            lower_mark='Lower',
            upper_mark='upper')

        if self._pattern is not None:
            for i, band in enumerate(self._pattern._bands):
                folding_table += self._band_to_folding_marks_line_str(i, band)

        folding_table += FOLDING_TABLE_FOOTER

        pattern_file.write(folding_table)
        pattern_file.close()
        print 'Your pattern has been saved to {file_path}.'.format(file_path=saving_path)

#####################################################################
# SLICE THE IMAGE
#####################################################################

def postprocess(wanted_width=None):
    self._filter_bands()
    self._even_slice_spacing(wanted_width)
    self._isolate_bands()
    self._generate_pattern_image()
    self._check_pattern()
    #self.save_pattern()

def _filter_bands(self):
    threshold = max((self.height(raw=True) // 40), 2)
    for i in range(len(self._slices)):
        raw_slice = self._slices[i]
        new_slice = []
        for band in raw_slice:
            if (band[1]-band[0]) > threshold:
                new_slice.append(band)
        self._slices[i] = new_slice

def _even_slice_spacing(wanted_width=None):
    self._identify_band_ranges()
    self._calculate_dropout_factor(wanted_width)
    self._calculate_step_ranges()

def _identify_band_ranges(self):
    self._band_ranges = []
    current_count = len(self._slices[0])
    current_start = 0
    for i, s in enumerate(self._slices):
        if s:
            self._band_count.add(len(s))
        else:
            self._band_count.add(1) # an empty slice (blank column) counts as a single band
        if len(s) != current_count:
            self._band_ranges.append((current_start, i, current_count))
            current_start = i
            current_count = len(s)
        if i == len(self._slices) - 1:
            self._band_ranges.append((current_start, len(self._slices), current_count))

def _calculate_dropout_factor(wanted_width=None):
    """Once evened the pattern has roughly the same width as the original image.
    Number of bands ~= number of slices = image width"""
    self._dropout_factor = 1
    if wanted_width is not None:
        self._dropout_factor = float(self.width(raw=True)) / float(wanted_width)
        self._dropout_factor = int(math.ceil(self._dropout_factor))
        self._dropout_factor = max(1, self._dropout_factor)

def _calculate_step_ranges(self):
    for (s, e, c) in self._band_ranges:
        if c:
            self._step_ranges.append((s, e, self._dropout_factor * c))
        else:
            self._step_ranges.append((s, e, self._dropout_factor))

def _check_pattern(self):
    if self.width(False) < self._min_band_count:
        print '! Warning ! The resolution of the pattern might be too low'
    if self.width(False) > self._max_band_count:
        print '! Warning ! The pattern will require a huge number of pages to fold'

def _isolate_bands(self):
    self._bands = []
    for (i_s, i_e, step) in self._step_ranges:
        for s in self._slices[i_s:i_e:step]:
            self._bands += s
            if len(s) == 0:     # if the slice is blank we represent it by an empty band
                self._bands.append((0,0))       # otherwise the pattern would skip the blank parts

###############################################################################
# MAP THE IMAGE TO THE BOOK
###############################################################################

def sheet_count(self):  # the actual number of pages used in the pattern
    total_sheet_count = int(math.ceil(float(self._last_page - self._first_page + 1) / 2.0))
    pattern_sheet_count = total_sheet_count - 2 * self._horizontal_margin
    pattern_sheet_count = max(pattern_sheet_count, 0)
    return (self._horizontal_margin, pattern_sheet_count, self._horizontal_margin, total_sheet_count)

def sheet_height(self):
    pattern_height = self._sheet_height - 2.0 * self._vertical_margin
    pattern_height = round(max(0.0, pattern_height), 3)
    return (self._vertical_margin, pattern_height, self._vertical_margin, self._sheet_height)

def sheet_spacing(self):
    max_spacing = 2.0 * 3.1416 * self._sheet_depth
    max_spacing = max_spacing / self.sheet_count()[3]
    return (0.25 * max_spacing, 0.5 * max_spacing, max_spacing)

def aspect_ratio(self):
    """Gives the range of possible ratios for the folded pattern.
    The ratio can be adjusted by opening the book more or less.
    The calculation is made with fixed margins."""
    pattern_sheet_count = self.sheet_count()[1]
    pattern_height = self.sheet_height()[1]
    pattern_ratio = float(pattern_sheet_count) / pattern_height
    min_ratio = self.sheet_spacing()[0] * pattern_ratio
    max_ratio = self.sheet_spacing()[2] * pattern_ratio
    opt_ratio = self.sheet_spacing()[1] * pattern_ratio
return (min_ratio, opt_ratio, max_ratio)

def horizontal_ranges(self):
    pattern_start_page = self._first_page + 2 * self._horizontal_margin
    pattern_end_page = pattern_start_page + 2 * self.sheet_count()[1]
    return (self._first_page, pattern_start_page, pattern_end_page, self._last_page)

def vertical_ranges(self):
    return (0.0, self._vertical_margin, self._sheet_height - self._vertical_margin, self._sheet_height)

def name(self):
    book_name = ''
    if self._pattern is not None:
        book_name = self._pattern.name()
    return book_name

def set_size(self, first_page_number, last_page_number, sheet_height, sheet_depth):
    self._first_page = first_page_number
    self._last_page = last_page_number
    self._sheet_height = sheet_height
    self._sheet_depth = sheet_depth

def set_pattern(self, pattern):
    self._pattern = pattern
    self._calculate_margins()
    if self._pattern.width(raw=False) > self.sheet_count()[3]:
        print NOT_ENOUGH_PAGES_WARNING.format(
                sheet_count=self.sheet_count()[3],
                band_count=self._pattern.width(raw=False)) 

def _calculate_margins(self):
    self._calculate_horizontal_margin()
    self._calculate_book_opening()
    self._calculate_vertical_margin()

def _calculate_horizontal_margin(self):
    self._horizontal_margin = 0
    if self._pattern is not None:
        self._horizontal_margin = self.sheet_count()[3] - self._pattern.width(raw=False)
        self._horizontal_margin = max(0, self._horizontal_margin) // 2

def _calculate_book_opening(self):
    self._book_opening = 180
    if self._pattern is not None:
        pattern_width_360 = self.sheet_spacing()[2] * float(self.sheet_count()[1])
        pattern_height_360 = pattern_width_360 / self._pattern.aspect_ratio(raw=True)
        pattern_to_sheet_ratio = pattern_height_360 / self.sheet_height()[3]
        if pattern_to_sheet_ratio < 1.0:
            self._book_opening = 360
        elif pattern_to_sheet_ratio < 2.0:
            self._book_opening = 180
        else:
            self._book_opening = 90

def _calculate_vertical_margin(self):
    self._vertical_margin = 0.0
    if self._pattern is not None:
        pattern_width_360 = self.sheet_spacing()[2] * float(self.sheet_count()[1])
        pattern_height_360 = pattern_width_360 / self._pattern.aspect_ratio(raw=True)
        self._vertical_margin = 0.5 * self.sheet_height()[3]
        if self._book_opening == 360:
            self._vertical_margin -= 0.5 * pattern_height_360
        elif self._book_opening == 180:
            self._vertical_margin -= 0.25 * pattern_height_360
        else:
            self._vertical_margin -= 0.125 * pattern_height_360
        self._vertical_margin = max(0.0, self._vertical_margin)
        self._vertical_margin = round(self._vertical_margin, 3)


###############################################################################
# END TO END WORKFLOW
###############################################################################

def preprocess(invert=False):
    self._fill_background()
    self._transform_black_white()
    self._emphasize_image()
    self._transform_binary()
    self._crop_image()
    self._smooth_image()
    
    if invert:
        self._invert()

def slice_image(self):
    self._slices = np.empty((self.width(raw=True),),dtype=object)
    temp = np.array(self._image).transpose()
    for x in xrange(self.width(raw=True)):
        self._slices[x] = []
        previous_color = True   # white
        current_color = True    # white, the picture is encoded in binary
        current_start = -1
        current_end = -1
        for y in xrange(self.height(raw=True)):
            current_color = temp[x, y]
            if current_color != previous_color:
                if current_color:
                    current_end = y - 1     # can't happen at y=0
                    self._slices[x].append((current_start, current_end))
                    current_start = -1
                    current_end = -1
                else:
                    current_start = y
            if y >= (self.height(raw=True) - 1):
                if current_color == False:
                    self._slices[x].append((current_start, self.height(raw=True) - 1))
            previous_color = current_color

def postprocess(wanted_width=None):
    self._filter_bands()
    self._even_slice_spacing(wanted_width)
    self._isolate_bands()
    self._generate_pattern_image()
    self._check_pattern()
    #self.save_pattern()
