# -*- coding: utf-8 -*-

"""
===========
Folding Art
===========

Calculate how to fold pages to print an image into the depth of a book.

It is chosen to match the aspect ratio of the pattern, which is considered fixed.
To adjust the aspect ratio of the folded pattern, you can play with :
    - the book size (sheet size, number of pages)
    - the margins around the folded pattern (optimal values are calculated)
    - the opening of the book (3 cases : 90, 180 and 360)
"""

from __future__ import division, print_function, absolute_import

import math

import numpy as np
from PIL import Image

from typical import checks, iterable, numeric

from overworked._coordinates import (
    arc_length,
    aspect_ratio,
    coordinate_ratio,
    range_length)
from overworked._image_processing import (
    convert_alpha_to_color,
    convert_color_to_binary,
    convert_range_to_band,
    crop_empty_spaces,
    emphasize,
    invert,
    smooth)

###############################################################################
# OUTPUT CONSTANTS
###############################################################################

IMAGE_SPECIFICATIONS_STR = """image ({width} x {height}) ratio {ratio}"""

PATTERN_SPECIFICATIONS_STR = """pattern ({width} x {height}) ratio {ratio}"""

BOOK_PAGE = """
"""

SHEET_SIZE_LINE ="""
"""

HORIZONTAL_MARGIN_LINE = """
"""

VERTICAL_MARGIN_LINE = """
"""

FOLDING_TABLE_DISCLAIMER = """{name:=<080}
The folding marks are measured from the bottom of the page.
The blank pages are meant to be folded all the way, from top to bottom.
The measures are given in cm.
===============================================================================
"""

FOLDING_TABLE_HEADER = """
===============================================================================
{page: <04}\t{lower_mark: <05}\t{upper_mark: <05}
===============================================================================\n"""

FOLDING_TABLE_FOOTER = """
===============================================================================
Generated by the OverWorked Moodule.
Licensed under MIT.
Enjoy your time folding !"""

FOLDING_TABLE_BLANK_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\tThis page is WHITE = folded all the way!\n"""

FOLDING_TABLE_FOLDED_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\n"""

FOLDING_TABLE_BLACK_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}\tThis page is BLACK = not folded !\n"""

NOT_ENOUGH_PAGES_WARNING = """! The book has only {sheet_count} sheets of paper while the pattern requires {band_count} !"""

###############################################################################
# PATTERN
###############################################################################

@checks
def is_white(
        start: numeric,
        end: numeric) -> bool:
    """
    Says whether a pattern band is blank.
    """
    return (start >= end)

@checks
def is_black(
        start: numeric,
        end: numeric) -> bool:
    """
    Says whether a pattern band is black.
    """
    return (
        start <= 0.0
        and end >= 1.0)

#####################################################################
# SLICE THE IMAGE
#####################################################################

def _count_slice_ranges(
        slices: iterable):
    return sum([len(__slice) for __slice in slices])

def _calculate_dropout_factor(
        original_width: int,
        wanted_width: int):
    """Once evened the pattern has roughly the same width as the original image.
    Number of bands ~= number of slices = image width"""
    return max(
        1,
        math.ceil(float(original_width) / float(wanted_width)))

def _isolate_ranges(
        slices):
    return [
        __band for __band in __slice
        for __slice in slices]

@checks
def _filter_ranges(
        ranges: iterable,
        threshold: float=0.05) -> iterable:
    """
    One range per sheet of paper.
    """
    return [
        (0.0, 0.0) if range_length(__range[0], __range[1]) < threshold
        else __range
        for __range in ranges]

@checks
def _image_band_to_slice(
        band: iterable) -> iterable:
    """
    Works only on binary images: there's no color information in the output
    ranges. The folding ranges are always black in this case.
    """
    __slice = []
    __height = np.size(band)
    __current_color = True   # white
    __current_start = -1.0

    # scan the band for continuous ranges of black pixels
    for __y in range(np.size(band)): # works on base iterable types as well arrays
        # close a continuous black range
        if band[__y] and not __current_color:
            __slice.append((
                __current_start,
                coordinate_ratio(
                    coordinate=__y, # upper bound excluded from the range, last=y-1
                    dimension=__height,
                    reverse=False)))
        elif not band[__y] and __current_color:
            __current_start = coordinate_ratio(
                coordinate=__y,
                dimension=__height,
                reverse=False)
        __current_color = band[__y]

    # finished scanning the band
    if not __current_color: # close the last open black range
        __slice.append((__current_start, 1.0))
    elif __current_color and __current_start == -1.0:
        __slice.append((0.0, 0.0)) # white page / slice / image band

    return __slice

###############################################################################
# MAP THE IMAGE TO THE BOOK
###############################################################################

def _calculate_margins():
    _calculate_horizontal_margin()
    _calculate_book_opening()
    _calculate_vertical_margin()

def _calculate_horizontal_margin():
    _horizontal_margin = 0
    if _pattern is not None:
        _horizontal_margin = sheet_count()[3] - _pattern.width(raw=False)
        _horizontal_margin = max(0, _horizontal_margin) // 2

def _calculate_book_opening():
    _book_opening = 180
    if _pattern is not None:
        pattern_width_360 = sheet_spacing()[2] * float(sheet_count()[1])
        pattern_height_360 = pattern_width_360 / _pattern.aspect_ratio(raw=True)
        pattern_to_sheet_ratio = pattern_height_360 / sheet_height()[3]
        if pattern_to_sheet_ratio < 1.0:
            _book_opening = 360
        elif pattern_to_sheet_ratio < 2.0:
            _book_opening = 180
        else:
            _book_opening = 90

def _calculate_vertical_margin():
    _vertical_margin = 0.0
    if _pattern is not None:
        pattern_width_360 = sheet_spacing()[2] * float(sheet_count()[1])
        pattern_height_360 = pattern_width_360 / _pattern.aspect_ratio(raw=True)
        _vertical_margin = 0.5 * sheet_height()[3]
        if _book_opening == 360:
            _vertical_margin -= 0.5 * pattern_height_360
        elif _book_opening == 180:
            _vertical_margin -= 0.25 * pattern_height_360
        else:
            _vertical_margin -= 0.125 * pattern_height_360
        _vertical_margin = max(0.0, _vertical_margin)
        _vertical_margin = round(_vertical_margin, 3)


###############################################################################
# END TO END WORKFLOW
###############################################################################

@checks
def preprocess(
        image: Image.Image,
        invert: bool=False) -> Image.Image:
    __temp = convert_color_to_binary(emphasize(
        convert_alpha_to_color(image).convert('L')))
    
    if invert:
        return smooth(crop_empty_spaces(invert(__temp)))
    else:
        return smooth(crop_empty_spaces(__temp))

@checks
def slice_image(
        image: Image.Image) -> iterable:
    return [
        _image_band_to_slice(__band)
        for __band in np.array(image).transpose()] # transpose so that second dimension is y

@checks
def postprocess(wanted_width=None):
    _filter_bands()
    _even_slice_spacing(wanted_width)
    _isolate_bands()
    _generate_pattern_image()
    _check_pattern()
    #save_pattern()
