# -*- coding: utf-8 -*-

"""
===========
Folding Art
===========

Calculate how to fold pages to print an image into the depth of a book.

Jargon:
- an image band is a 1-pixel wide vertical portion of the image 
- a pattern slice is a continuous stroke of a single color in an image band
Each pattern slice is meant to map a book sheet.

It is chosen to match the aspect ratio of the pattern, which is considered fixed.
To adjust the aspect ratio of the folded pattern, you can play with :
    - the book size (sheet size, number of pages)
    - the margins around the folded pattern (optimal values are calculated)
    - the opening of the book (3 cases : 90, 180 and 360)
"""

from __future__ import division, print_function, absolute_import

import math

import numpy as np
from PIL import Image

from typical import checks, iterable, numeric

from overworked._coordinates import (
    arc_length,
    aspect_ratio,
    coordinate_to_ratio,
    range_length,
    ratio_to_coordinate,
    sheet_ordinate,
    sheet_page)
from overworked._image_processing import (
    convert_alpha_to_color,
    convert_color_to_binary,
    convert_range_to_band,
    crop_empty_spaces,
    emphasize,
    invert,
    smooth)

###############################################################################
# OUTPUT CONSTANTS
###############################################################################

IMAGE_SPECIFICATIONS_STR = """image ({width} x {height}) ratio {ratio}"""

PATTERN_SPECIFICATIONS_STR = """pattern ({width} x {height}) ratio {ratio}"""

BOOK_PAGE = """
"""

SHEET_SIZE_LINE ="""
"""

HORIZONTAL_MARGIN_LINE = """
"""

VERTICAL_MARGIN_LINE = """
"""

FOLDING_TABLE_DISCLAIMER = """{name:=<080}
The folding marks are measured from the bottom of the page.
The blank pages are meant to be folded all the way, from top to bottom.
The measures are given in cm.
===============================================================================
"""

FOLDING_TABLE_HEADER = """
===============================================================================
{page: <04}\t{lower_mark: <05}\t{upper_mark: <05}
===============================================================================\n"""

FOLDING_TABLE_FOOTER = """
===============================================================================
Generated by the OverWorked Moodule.
Licensed under MIT.
Enjoy your time folding !"""

FOLDING_TABLE_LINE = """{page: <04d}\t{lower: <05.1f}\t{upper: <05.1f}{message}\n"""

WHITE_LINE_WARNING = """\tThis page is WHITE = folded all the way!\n"""

BLACK_LINE_WARNING = """\tThis page is BLACK = not folded !\n"""

NOT_ENOUGH_PAGES_WARNING = """! The book has only {sheet_count} sheets of paper while the pattern requires {band_count} !"""

###############################################################################
# PATTERN
###############################################################################

@checks
def is_white(
        lower: numeric,
        upper: numeric) -> bool:
    """
    Says whether a pattern band is blank.

    Parameters
    ----------
    lower: numeric :
        
    upper: numeric :
        

    Returns
    -------

    """
    return (lower >= upper)

@checks
def is_black(
        lower: numeric,
        upper: numeric) -> bool:
    """
    Says whether a pattern band is black.

    Parameters
    ----------
    lower: numeric :
        
    upper: numeric :
        

    Returns
    -------

    """
    return (
        lower <= 0.0
        and upper >= 1.0)

#####################################################################
# SLICE THE IMAGE
#####################################################################

@checks
def _image_band_to_pattern_slice(
        band: iterable) -> iterable:
    """
    Works only on binary images: there's no color information in the output
    ranges. The folding ranges are always black in this case.

    Parameters
    ----------
    band: iterable :
        

    Returns
    -------

    """
    __slice = []
    __height = np.size(band)
    __current_color = True   # white
    __current_start = -1.0

    # scan the band for continuous ranges of black pixels
    for __y in range(np.size(band)): # works on base iterable types as well arrays
        # close a continuous black range
        if band[__y] and not __current_color:
            __slice.append((
                __current_start,
                coordinate_to_ratio(
                    coordinate=__y, # upper bound excluded from the range, last=y-1
                    dimension=__height,
                    reverse=False)))
        elif not band[__y] and __current_color:
            __current_start = coordinate_to_ratio(
                coordinate=__y,
                dimension=__height,
                reverse=False)
        __current_color = band[__y]

    # finished scanning the band
    if not __current_color: # close the last open black range
        __slice.append((__current_start, 1.0))
    elif __current_color and __current_start == -1.0:
        __slice.append((0.0, 0.0)) # white page / slice / image band

    return __slice

@checks
def _flatten_pattern_slices(
        slices: iterable) -> iterable:
    """
    One range per sheet of paper.

    Parameters
    ----------
    slices: iterable :
        

    Returns
    -------

    """
    return [
        __band
        for __slice in slices
        for __band in __slice]

@checks
def _filter_pattern_slices(
        slices: iterable,
        threshold: float=0.05) -> iterable:
    """
    Filter out the small slices: they make the pattern wider and don't render
    well as folded pages.

    Parameters
    ----------
    slices: iterable :
        
    threshold: float :
         (Default value = 0.05)

    Returns
    -------

    """
    return [
        (0.0, 0.0) if range_length(__slice[0], __slice[1]) < threshold
        else __slice
        for __slice in slices]

###############################################################################
# MAP THE IMAGE TO THE BOOK
###############################################################################

@checks
def _calculate_pattern_slice_dropout_factor(
        original_width: int,
        wanted_width: int) -> int:
    """
    Once evened the pattern has roughly the same width as the original image.
    Number of bands ~= number of slices = image width

    Parameters
    ----------
    original_width: int :
        
    wanted_width: int :
        

    Returns
    -------

    """
    return max(
        1,
        math.ceil(float(original_width) / float(wanted_width)))

def _calculate_margins():
    """ """
    _calculate_horizontal_margin()
    _calculate_book_opening()
    _calculate_vertical_margin()

def _calculate_horizontal_margin():
    """ """
    _horizontal_margin = 0
    if _pattern is not None:
        _horizontal_margin = sheet_count()[3] - _pattern.width(raw=False)
        _horizontal_margin = max(0, _horizontal_margin) // 2

def _calculate_book_opening():
    """ """
    _book_opening = 180
    if _pattern is not None:
        pattern_width_360 = sheet_spacing()[2] * float(sheet_count()[1])
        pattern_height_360 = pattern_width_360 / _pattern.aspect_ratio(raw=True)
        pattern_to_sheet_ratio = pattern_height_360 / sheet_height()[3]
        if pattern_to_sheet_ratio < 1.0:
            _book_opening = 360
        elif pattern_to_sheet_ratio < 2.0:
            _book_opening = 180
        else:
            _book_opening = 90

def _calculate_vertical_margin():
    """ """
    _vertical_margin = 0.0
    if _pattern is not None:
        pattern_width_360 = sheet_spacing()[2] * float(sheet_count()[1])
        pattern_height_360 = pattern_width_360 / _pattern.aspect_ratio(raw=True)
        _vertical_margin = 0.5 * sheet_height()[3]
        if _book_opening == 360:
            _vertical_margin -= 0.5 * pattern_height_360
        elif _book_opening == 180:
            _vertical_margin -= 0.25 * pattern_height_360
        else:
            _vertical_margin -= 0.125 * pattern_height_360
        _vertical_margin = max(0.0, _vertical_margin)
        _vertical_margin = round(_vertical_margin, 3)

#####################################################################
# VIEWING & EXPORTING
#####################################################################

@checks
def _pattern_slice_to_image_band(
        slice_: tuple,
        height: int) -> iterable:
    """
    

    Parameters
    ----------
    slice_: tuple :
        
    height: int :
        

    Returns
    -------

    """
    __band = True * np.ones((height,))
    for __y in range(
            ratio_to_coordinate(slice_[0], height, reverse=False),
            ratio_to_coordinate(slice_[1], height, reverse=False)):
        __band[__y] = False

    return __band

@checks
def _pattern_slice_to_folding_marks(
        page: int,
        sheet_height: numeric,
        sheet_margin: numeric,
        slice_: iterable) -> str:
    """
    

    Parameters
    ----------
    page: int :
        
    sheet_height: numeric :
        
    sheet_margin: numeric :
        
    slice_: iterable :
        

    Returns
    -------

    """
    __message = ''
    if is_black(lower=slice_[0], upper=slice_[1]):
        __message = BLACK_LINE_WARNING
    elif is_white(lower=slice_[0], upper=slice_[1]):
        __message = WHITE_LINE_WARNING

    return FOLDING_TABLE_LINE.format(
        page=page,
        lower=sheet_ordinate(
            ratio=slice_[0],
            height=sheet_height,
            margin=sheet_margin),
        upper=sheet_ordinate(
            ratio=slice_[1],
            height=sheet_height,
            margin=sheet_margin),
        message=__message)

@checks
def generate_folding_pattern_preview_image(
        slices: iterable,
        height: int,
        spacing: int=1) -> Image.Image:
    """
    The sheet is surrounded by [spacing] columns :
    - at the center is the actual paper, a line of 1 pixel
    - the surrounding columns are white
    
    It's meant to represent the spacing of the sheets of paper,
    when the book is opened.

    Parameters
    ----------
    slices: iterable :
        
    height: int :
        
    spacing: int :
         (Default value = 1)

    Returns
    -------

    """
    __bands = True * np.ones((
        spacing * (len(slices) + 1) + len(slices),
        height))

    for i in range(len(slices)):
        __bands[i * (spacing + 1), :] = _pattern_slice_to_image_band(
            slice_=slices[i],
            height=height)

    return Image.fromarray(
        obj=__bands.transpose(), # the PIL image is an array of horizontal bands
        mode='1')

@checks
def generate_folding_table(
        name: str,
        first_page: int,
        sheet_height: int,
        horizontal_margin: int,
        vertical_margin: numeric,        
        slices: iterable,) -> str:
    """
    

    Parameters
    ----------
    name: str :
        
    first_page: int :
        
    sheet_height: int :
        
    horizontal_margin: int :
        
    vertical_margin: numeric :
        
    slices: iterable :
        

    Returns
    -------

    """
    __folding_table = FOLDING_TABLE_DISCLAIMER.format(
        name='= ' + name + ' ')
    
    __folding_table += FOLDING_TABLE_HEADER.format(
        page='Page',
        lower_mark='Lower',
        upper_mark='upper')

    for i, __slice in enumerate(slices):
        __folding_table += _pattern_slice_to_folding_marks(
            page=sheet_page(
                index=i,
                first_page=first_page,
                margin=horizontal_margin),
            sheet_height=sheet_height,
            sheet_margin=vertical_margin,
            slice_= __slice)

    __folding_table += FOLDING_TABLE_FOOTER

    return __folding_table

###############################################################################
# END TO END WORKFLOW
###############################################################################

@checks
def preprocess_image(
        image: Image.Image,
        colors: int=2,
        invert: bool=False) -> Image.Image:
    """
    

    Parameters
    ----------
    image: Image.Image :
        
    colors: int :
         (Default value = 2)
    invert: bool :
         (Default value = False)

    Returns
    -------

    """
    __temp = convert_color_to_binary(emphasize(
        convert_alpha_to_color(image).convert('L')))
    
    if invert:
        return smooth(crop_empty_spaces(invert(__temp)))
    else:
        return smooth(crop_empty_spaces(__temp))

@checks
def slice_image(
        image: Image.Image) -> iterable:
    """
    

    Parameters
    ----------
    image: Image.Image :
        

    Returns
    -------

    """
    return [
        _image_band_to_pattern_slice(__band)
        for __band in np.array(image).transpose()] # transpose so that second dimension is y

@checks
def postprocess_folding_pattern(
        slices: iterable) -> iterable:
    """
    

    Parameters
    ----------
    slices: iterable :
        

    Returns
    -------

    """
    return _filter_pattern_slices(
        slices=_flatten_pattern_slices(slices=slices),
        threshold=0.05)

@checks
def map_folding_pattern_to_book(wanted_width=None):
    """
    

    Parameters
    ----------
    wanted_width :
         (Default value = None)

    Returns
    -------

    """
    _generate_pattern_image()
    _check_pattern()
    #save_pattern()
